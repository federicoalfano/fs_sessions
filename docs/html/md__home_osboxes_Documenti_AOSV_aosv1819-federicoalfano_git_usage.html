<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Session Module: Tips on using Git and GitHub</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Session Module
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tips on using Git and GitHub </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Some tips on how to use git and GitHub are provided in this document. This is not the only way to use these tools. Neverthless, from my experience, if you adhere to these rules, you are less likely to break everything up.</p>
<h2>Branching Model</h2>
<p>A good branching model ensures that the mergeability likelihood is high, and that the patches that you produce can be integrated seamlessy and quickly. The adopted branching model can be summarized as follows:</p>
<div class="image">
<img src="https://github.com/HPDCS/ROOT-Sim/wiki/images/branching-model.png"  alt="Branching Model" title="Branching Model"/>
</div>
<p>A good branching model (like the one which is described here) is essentially no more than a set of procedures that every team member has to follow in order to come to a managed software development process.</p>
<h3>The main branches</h3>
<div class="image">
<img src="https://github.com/HPDCS/ROOT-Sim/wiki/images/branching-model-main-branches.png"  alt="Main Branches" title="Main Branches"/>
</div>
<p>The repo holds two main branches with an infinite lifetime:</p>
<ul>
<li><code>master</code></li>
<li><code>develop</code></li>
</ul>
<p>The <code>master</code> branch at origin should be familiar to every Git user. Parallel to the <code>master</code> branch, another branch exists called <code>develop</code>.</p>
<p>We consider <code>origin/master</code> to be the main branch where the source code of <code>HEAD</code> always reflects a *production-ready* state.</p>
<p>We consider <code>origin/develop</code> to be the main branch where the source code of <code>HEAD</code> always reflects a state with the latest delivered development changes for the next release. Some would call this the "*integration branch*".</p>
<p>When the source code in the <code>develop</code> branch reaches a stable point and is ready to be released, all of the changes should be merged back into <code>master</code> somehow and then tagged with a release number. How this is done in detail will be discussed further on.</p>
<p>Therefore, each time when changes are merged back into <code>master</code>, this is a new production release <em>by definition</em>. This must be enforced strictly: if there is some issue which is still known to be in the <code>origin/develop</code> for some reason, then <code>origin/develop</code> should not be merged into <code>origin/master</code>.</p>
<p><code>origin/master</code> is a <em>protected branch</em>: no one can directly push into it. This branch is used only by relying on <em>pull requests</em>, and the repository rules enforce that all automatic integration checks must pass in order to merge, and at least two independent code reviews are required for a pull request to be merged. This should reduce the chances that a broken release is delivered.</p>
<h3>Supporting Branches</h3>
<p>Next to the main branches <code>master</code> and <code>develop</code>, our development model uses a variety of supporting branches to aid parallel development between team members, ease tracking of features, prepare for production releases and to assist in quickly fixing live production problems. Unlike the main branches, these branches always have a limited life time, since they will be removed eventually.</p>
<p>The different types of branches we may use are:</p>
<ul>
<li>Feature branches</li>
<li>Hotfix branches</li>
<li>Release branches</li>
</ul>
<p>Each of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets. We will walk through them shortly.</p>
<p>By no means are these branches "special" from a technical perspective. The branch types are categorized by how we use them. They are of course plain old Git branches.</p>
<p>In general, if you want to contribute by delevoping a <em>new feature</em>, you should use a <b>feature branch</b>. If you have spotted a bug and have a patch for it, you should rely on a <b>hotfix branch</b>.</p>
<p>The semantics behind these branches are described below.</p>
<h3>Feature Branches</h3>
<div class="image">
<img src="https://github.com/HPDCS/ROOT-Sim/wiki/images/branching-model-feature.png"  alt="Feature Branches" title="Feature Branches"/>
</div>
<table class="doxtable">
<tr>
<th align="right">Rule </th><th>Description  </th></tr>
<tr>
<td align="right">May branch from: </td><td><code>develop</code> </td></tr>
<tr>
<td align="right">Must merge back into: </td><td><code>develop</code> </td></tr>
<tr>
<td align="right">Naming convention: </td><td>anything except <code>master</code>, <code>develop</code>, <code>release-*</code>, or <code>hotfix-*</code> </td></tr>
</table>
<p>Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point (an issue marked as a development note might result in such a branch). The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).</p>
<p>Feature branches typically exist in developer repos only, not in <code>origin</code>, although we do not necessarily strictly enforce this.</p>
<h4>Creating a feature branch</h4>
<p>When starting work on a new feature, branch off from the <code>develop</code> branch.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git checkout -b myfeature develop</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Switched to a new branch &quot;myfeature&quot;</div></div><!-- fragment --><h4>Incorporating a finished feature on <code>develop</code></h4>
<p>It is a good practice to issue a <b>Pull Request</b> to incorporate a feature branch into develop, and ask at least for one code review.</p>
<p>Finished features may be anyhow merged into the develop branch definitely add them to the upcoming release, provided that extensive tests have been carried:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git checkout develop</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Switched to branch &#39;develop&#39;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ git merge --no-ff myfeature</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Updating ea1b82a..05e9557</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;(Summary of changes)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;$ git branch -d myfeature</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;Deleted branch myfeature (was 05e9557).</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;$ git push origin develop</div></div><!-- fragment --><p>In case you want to delete the remote branch, you can additionally run:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;git push origin --delete myfeature</div></div><!-- fragment --><p>The <code>--no-ff</code> flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature. Compare:</p>
<div class="image">
<img src="https://github.com/HPDCS/ROOT-Sim/wiki/images/branching-model-feature-merge.png"  alt="Merging Feature Branches" title="Merging Feature Branches"/>
</div>
<p>In the latter case, it is impossible to see from Git history which of the commit objects together have implemented a feature (you would have to manually read all the log messages). Reverting a whole feature (i.e. a group of commits), is a true headache in the latter situation, whereas it is easily done if the <code>--no-ff</code> flag was used. Yes, it will create a few more (empty) commit objects, but the gain is much bigger that that cost.</p>
<p>Merging into <code>develop</code> is sometimes referred to as "merge window". Once a new release branch is created (see below), new features are automatically directed towards the next release.</p>
<p>Once a feature branch is closed, the contributor is required to create a short notice on the project website, Please, see section <em>Short Notes on the Project Website</em> below.</p>
<h3>Release Branches</h3>
<table class="doxtable">
<tr>
<th align="right">Rule </th><th>Description  </th></tr>
<tr>
<td align="right">May branch from: </td><td><code>develop</code> </td></tr>
<tr>
<td align="right">Must merge back into: </td><td><code>develop</code> and <code>master</code> </td></tr>
<tr>
<td align="right">Naming convention: </td><td><code>release-*</code> </td></tr>
</table>
<p>Release branches support preparation of a new production release. They allow for last-minute dotting of i's and crossing t's. Furthermore, they allow for minor bug fixes and preparing meta-data for a release (version number, build dates, etc.). By doing all of this work on a release branch, the <code>develop</code> branch is cleared to receive features for the next big release.</p>
<p>The key moment to branch off a new release branch from <code>develop</code> is when <code>develop</code> (almost) reflects the desired state of the new release. At least all features that are targeted for the release-to-be-built must be merged in to <code>develop</code> at this point in time. All features targeted at future releases may not: they must wait until after the release branch is branched off.</p>
<p>It is exactly at the start of a release branch that the upcoming release gets assigned a version number, not any earlier. Up until that moment, the <code>develop</code> branch reflected changes for the "next release", but it is unclear whether that "next release" will eventually become 0.3 or 1.0, until the release branch is started. That decision is made on the start of the release branch and is carried out by the project's rules on version number bumping.</p>
<h4>Creating a release branch </h4>
<p>Release branches are created from the <code>develop</code> branch. For example, say version 1.1.5 is the current production release and we have a big release coming up. The state of develop is ready for the "next release". So we branch off and give the release branch a name reflecting the new version number:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git checkout -b release-1.2.0 develop</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Switched to a new branch &quot;release-1.2.0&quot;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ ./bump-version.sh</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Files modified successfully, version bumped to 1.2.0</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;$ git commit -s -a -m &quot;Bumped version number to 1.2.0&quot;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[release-1.2.0 74d9424] Bumped version number to 1.2.0</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;1 files changed, 1 insertions(+), 1 deletions(-)</div></div><!-- fragment --><p>After creating a new branch and switching to it, we bump the version number. Here, <code>bump-version.sh</code> is a commodity shell script, which is not released in this sample repo (if you want to use it, you should implement it according to the versioning scheme that you adopt), that changes the relevant information in the source tree to reflect the new version.</p>
<p>This newly-created branch may exist there for a while, until the release may be rolled out definitely. During that time, bug fixes may be applied in this branch (rather than on the <code>develop</code> branch). Adding large new features here is <b>strictly prohibited</b>. They must be merged into <code>develop</code>, and therefore, wait for the next big release.</p>
<h4>Finishing a release branch </h4>
<p>When the state of the release branch is ready to become a real release, some actions need to be carried out.</p>
<p>First, the release branch must be merged into <code>master</code>. This action can be only done by issuing a Pull Request, and asking for two different code reviews which must positively pass. Also, all automatic tests (if you are using some sort of continuous integration) must pass.</p>
<p>Once the Pull Request is merged (again creating a no-fast-forward commit), the changes made on the release branch need to be merged back into <code>develop</code>, so that future releases also contain these bug fixes.</p>
<p>We then have to create a tag to identify the new release in <code>master</code>. By definition, all tags must be signed. This should be done by using git’s integration with PGP, so a key to identify the signer must be publicly available. At least, for easiness of retrieval, the public key of the person creating the tag should be published here:</p>
<ul>
<li><a href="http://pgp.mit.edu/">http://pgp.mit.edu/</a><a href="http://pgp.mit.edu/">http://pgp.mit.edu/</a></li>
<li><a href="http://keyserver.pgp.com/">http://keyserver.pgp.com/</a></li>
</ul>
<p>To set up git for using your private key to sign tags:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git config --global user.signingkey HASH</div></div><!-- fragment --><p>This allows to use <code>-s</code> as a shortcut to select the key for signing. If you don't want for some reason to globally set your key for signing, in the tag creation command you must replace <code>-s</code> with <code>-u &lt;key&gt;</code>.</p>
<p>The git steps to create the release from the <code>master branch</code> after that the Pull Request have been merged are:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git checkout master</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Switched to branch &#39;master&#39;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ git pull</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;(Summary of changes)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;$ git tag -s -a 1.2.0</div></div><!-- fragment --><p>Note that here you must manually specify a version number as the tag name, coherent with the version number which you are releasing.</p>
<p>To publish the tag on origin, the following command can be used:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git push --follow-tags</div></div><!-- fragment --><p>It pushes only "sane" tags, namely tags that are both:</p>
<ul>
<li>Annotated</li>
<li>Reachable (an ancestor) from the pushed commits</li>
</ul>
<p>This is sane because only annotated tags should be pushed on the remote, keeping lightweight tags for local development only, and doesnt push tags on unrelated branches. <code>git push --tags</code> should be avoided at all because it pushes all tags, not only "sane" ones.</p>
<p>The release is now done, and tagged for future reference. To keep the changes made in the release branch, we need to merge those back into <code>develop</code>, though. In git:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git checkout develop</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Switched to branch &#39;develop&#39;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ git merge --no-ff release-1.2.0</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Merge made by recursive.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;(Summary of changes)</div></div><!-- fragment --><p>This step may well lead to a merge conflict (probably even, since we have changed the version number). If so, fix it and commit.</p>
<p>Now we are really done and the release branch may be removed, since we don’t need it anymore:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git branch -d release-1.2</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Deleted branch release-1.2 (was ff452fe).</div></div><!-- fragment --><h3>Hotfix Branches</h3>
<div class="image">
<img src="https://github.com/HPDCS/ROOT-Sim/wiki/images/branching-model-hotfix.png"  alt="Hotfix Branches" title="Hotfix Branches"/>
</div>
<table class="doxtable">
<tr>
<th align="right">Rule </th><th>Description  </th></tr>
<tr>
<td align="right">May branch from: </td><td><code>master</code> </td></tr>
<tr>
<td align="right">Must merge back into: </td><td><code>develop</code> and <code>master</code> </td></tr>
<tr>
<td align="right">Naming convention: </td><td><code>hotfix-*</code> </td></tr>
</table>
<p>Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the <code>master</code> branch that marks the production version.</p>
<p>The essence is that work of team members (on the <code>develop</code> branch) can continue, while another person is preparing a quick production fix.</p>
<h4>Creating the hotfix branch </h4>
<p>Hotfix branches are created from the <code>master</code> branch. For example, say version 1.2.1 is the current production release running live and causing troubles due to a severe bug. But changes on <code>develop</code> are yet unstable. We may then branch off a hotfix branch and start fixing the problem:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git checkout -b hotfix-1.2.1 master</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Switched to a new branch &quot;hotfix-1.2.1&quot;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;$ ./bump-version.sh</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Files modified successfully, version bumped to 1.2.1.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;$ git commit -s -a -m &quot;Bumped version number to 1.2.1&quot;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;1 files changed, 1 insertions(+), 1 deletions(-)</div></div><!-- fragment --><p>Don't forget to bump the version number after branching off! Again, the <code>bump-version.sh</code> script will automatically determine the new version number starting from the branch name.</p>
<p>Then, fix the bug and commit the fix in one or more separate commits.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git commit</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;[hotfix-1.2.1-2 abbe5d6] Fixed severe production problem</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;5 files changed, 32 insertions(+), 17 deletions(-)</div></div><!-- fragment --><h4>Finishing a hotfix branch</h4>
<p>When finished, the bugfix needs to be merged back into <code>master</code>, but also needs to be merged back into <code>develop</code>, in order to safeguard that the bugfix is included in the next release as well. This is completely similar to how release branches are finished.</p>
<p>The one exception to the rule here is that, when a release branch currently exists, the hotfix changes need to be merged into that release branch, instead of <code>develop</code>.</p>
<p>Back-merging the bugfix into the release branch will eventually result in the bugfix being merged into <code>develop</code> too, when the release branch is finished.</p>
<p>(If work in develop immediately requires this bugfix and cannot wait for the release branch to be finished, you may safely merge the bugfix into <code>develop</code> now already as well.)</p>
<p>Finally, remove the temporary branch:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git branch -d hotfix-1.2.1</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Deleted branch hotfix-1.2.1 (was abbe5d6).</div></div><!-- fragment --><h2>Commits and Commit Messages</h2>
<p>A commit should be a self-contained update to the code tree. Despite bug fixes that could be introduced later in the development, a commit should be never considered as "I’m saving my work now, I’ll continue later", especially if the commit is pushed to a remote repository.</p>
<p>On the other hand, a commit should not contain multiple changes to the code base. If, during development, I have to change something in two different modules, and the changes are unrelated, then the changes should be placed in two different commits. That is: make separate commits for logically separate changes.</p>
<p>Making good commits is a form of art. A good way to decide whether a commit is self-contained, developers should answer themselves the question: "will I be able to cherry pick this commit in the future, shall I need it?". If the answer is yes, then most likely it is a good commit.</p>
<p>Commit messages should be meaningful. A one-line commit message like "I’m developing foo" will not allow other developers to understand what that commit is for. A minimal commit message would be of the format:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Short log</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;(Optional pointers to external resources, such as defect tracking)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;The intent of your change.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;(Optional, if it&#39;s not clear from above) how your change resolves the</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;issues in the first part.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Tag line(s) at the end.   </div></div><!-- fragment --><p>This is an example of a good commit message:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;foobar: Adjusted the foo setting in bar</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;When using foobar on systems with less than a gigabyte of RAM common</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;usage patterns often result in an Out-of-memory condition causing</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;slowdowns and unexpected application termination.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Low-memory systems should continue to function without running into</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;memory-starvation conditions with minimal cost to systems with more</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;available memory.  High-memory systems will be less able to use the</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;full extent of the system, a dynamically tunable option may be best,</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;long-term.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;The foo setting in bar was decreased from X to X-50% in order to</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;ensure we don&#39;t exhaust all system memory with foobar threads.</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Signed-off-by: Joe Developer &lt;joe.developer@example.com&gt;</div></div><!-- fragment --><p>Several things should be noted here. The minimal commit message is good for new code development and simple changes. An empty line must always come after it, otherwise post processing software might not be able to distinguish it from the rest of the commit text.</p>
<p>The single short log message indicates what needed to be changed. It should begin with an indicator as to the primary item changed by this work, followed by a short summary of the change. In the above case we're indicating that we've changed the "foobar" item, by "adjusting the foo setting in bar".</p>
<p>The single short log message is analogous to the git "commit summary". While no maximum line length is specified by this policy, it is suggested that it remains under 50 characters wherever possible. Think of it as the subject of an email: you should never write too much text in it, otherwise receivers will not understand easily what the email is about.</p>
<p>Optionally, you may include pointers to defects this change corrects. Unless the defect format is specified by the component you are modifying, it is suggested that you use a full URL to specify the reference to the defect information. Generally, these pointers will precede any long description, but as an optional item it may be after the long description. This could be a good way, for example, to refer to open issues in a bug tracker. You must then have a full description of the change. Specifying the intent of your change and if necessary how the change resolves the issue.</p>
<p>Finally, one or more tag lines should exist. Each developer responsible for working on the patch is responsible for adding a <code>Signed-off-by:</code> tag line. This tag line should be added by people writing the patch, and additional tag lines should be added by people, for example, merging the patch into different branches. This allows to easily track the updates to the code base, and determine who did what.</p>
<p>It is not acceptable to have an empty or non-existent header, or just a single line message. The summary and description is required for all changes.</p>
<p>The commit messages should be manually indented. Usually, each line of the message, should not be longer than 78 characters. Note that in order to do this easily, is always better to avoid using the <code>-m</code> switch when committing: in fact, simply issuing:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ git commit</div></div><!-- fragment --><p>will fire up the text editor specified in the <code>EDITOR</code> environment variable (you can set it to your preferred editor), so that you can freely write your commit message respecting the adopted layout. Note that if you set your favorite editor to vim, you can add the following lines to ~/.vimrc:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;filetype plugin indent on</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;au FileType gitcommit set tw=72</div></div><!-- fragment --><p>which automatically wraps the text to the specified 72 characters for git commit messages. To check whether vim is correctly identifying the commit message as gitcommit, the following command can be used within vi:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;:set filetype?</div></div><!-- fragment --><p>or to save a few keystrokes:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;:se ft?</div></div><!-- fragment --><p>If, for any reason, you have pushed commits with non-meaningful descriptions (due to hurry, pressure, <code>git fire</code>, etc.), these should never end up in the <code>master</code> branch. Here, interactively rebasing you local branch (and issuing a force push if possible) is a good practice. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>

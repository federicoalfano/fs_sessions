<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Session Module: Advanced Operating Systems and Virtualization - A.A. 2018/2019</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Session Module
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced Operating Systems and Virtualization - A.A. 2018/2019 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Final Project Report</h1>
<p><b>Student Full Name:</b> Federico Alfano</p>
<p><b>Student ID:</b> 1262220</p>
<h2>Introduction</h2>
<p>It's a subsystem that makes the user able to access a file using sessions. In this way every modification is not visible until the session is close. Many processes can access concurrently a given file. The system provides also some statistical information into the /sys/kernel/session-module directory where the user can:</p><ul>
<li>See the number of total open sessions</li>
<li>See the number of sessions per-process and per-file</li>
<li>See and change the path where the user can open sessions The idea is to create a new file, copy the old file into it and then redirect all the VFS operations on the session file overwriting the file operations. At the close, the session file is renamed as the old one and the last is unlinked.</li>
</ul>
<h2>User Space Library</h2>
<p>The userspace library is a simple interface that provides the user a set of operations to interact with the module. In particular the operations needed are:</p><ul>
<li>session_init: it starts the session and provides a session_id that is the file descriptor of the module</li>
<li>session_open: it tells the library to open a session on a given file, it needs as parameters the session_id and the file descriptor onto we want to open a session and returns 0 if no error and an error code if it fails.</li>
<li>session_close: it tells the library to close a session on a given file, it needs as parameters the session_id and the file descriptor onto we want to close a session.</li>
<li>session_exit: it ends the session closing the module All the operations are a call to the facilities provided by the module <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int session_init()</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return open(CHAR_DEVICE, O_RDWR);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;int session_open(int session_id, int fd)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{  </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    return ioctl(session_id, SESSION_OPEN, &amp;fd);  </div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;int session_close(int session_id, int fd)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;{   </div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    return ioctl(session_id, SESSION_CLOSE, &amp;fd); </div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;int session_exit(int session_id)</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;{   </div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        return close(session_id);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div></div><!-- fragment --></li>
</ul>
<h2>Kernel-Level Data Structures</h2>
<p>The subsystem has two global rbtrees that are represented respectively by:</p><ul>
<li>struct <a class="el" href="structsession__proc__node.html" title="This is the structure into the rb_tree that contains all the processes which are currently using the ...">session_proc_node</a></li>
<li>struct <a class="el" href="structsession__file__node.html" title="This is the structure into the rb_tree that contains all the open files with their counter...">session_file_node</a> They contain the counter for the per-process sessions and the per-file sessions. The system relies also on two global variables:</li>
<li>The base_path</li>
<li>session_counter The former is used to store the current base path where the sessions can live, the second keeps track of the total number of sessions. All data can be read into the /sys directory and the path can also be modified from the user.</li>
</ul>
<h2>Kernel-Level Subsystem Implementation</h2>
<h3>Initialization</h3>
<p>The initialization allocates dynamically a MAJOR and a single MINOR for the char device and then initializes that and set the global variable <em>my_cdev</em> that is a struct defined into the header, containing the char device and a kobject. The next step is the build of the sysfs tree that has the following structure:</p>
<div class="image">
<img src="SYSFS.png"  alt="Sysfs structure"/>
</div>
<p>the choice to use a single file for the file counters and to use multiple files for processes is just for a readability. The last step is to set the PWD as default base path</p>
<p><code>get_fs_pwd(current-&gt;fs ,&amp;base_path);</code></p>
<h3>Module operations</h3>
<p>The device initialization wants file_operations structure in order to control the behaviour of the module, the following implementations only needs three of them: -open -release -ioctl_unlocked The third one is the essence of the module, so deserves a dedicated paragraph. </p><h3>module_open</h3>
<p>It's called when the user wants to start to work with sessions, so the first thing to do is to check if a session is already open and return an EEXIST error if yes </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if((node = rb_search(&amp;root, pid, &amp;tree_rwlock)))</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;        return -EEXIST;</div></div><!-- fragment --><p>after that, it will create a node into the rbtree containing the processes: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;node = kmalloc(sizeof(struct session_proc_node), GFP_KERNEL);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    scnprintf(node-&gt;key, PROC_NAME_LENGTH, &quot;%d&quot;, current-&gt;pid);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    atomic_set(&amp;node-&gt;session_counter, 0);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    rb_insert(&amp;root, node, &amp;tree_rwlock);</div></div><!-- fragment --><p> The insertion is sensitive to race conditions, so it keeps a rwlock that is managed into the helper function in <em>file_utils.c</em>. And finally it creates a file into */sys/kernel/session_module/proc* directory with the number of open sessions.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;proc_counter_attr = get_attribute(node-&gt;key, 0444, proc_counter_show, NULL);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    node-&gt;attr = (const struct attribute*) &amp;proc_counter_attr-&gt;attr;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    sysfs_create_file(proc_kobj, &amp;proc_counter_attr-&gt;attr);</div></div><!-- fragment --><h3>module_release</h3>
<p>Essentially the release method is a check to verify if the user has closed the module in the right way, so it checks if the node related to the process is still present into the rbtree and after removing that it raises a SIGPIPE </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(current_node!=NULL)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    clear_proc_node();                  </div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    send_sig(SIGPIPE, current, 0);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><h3>module_ioctl</h3>
<p>The function is in charge to manage all the operations to the file, let's see them in detail:</p>
<h4>OPEN_SESSION</h4>
<p>This is the operation called at the session opening, after some check on the validity of the file and of permissions it performs the following operations:</p>
<ul>
<li>Creates a temporary file with the same content and flags of the original one</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;session_filp = filp_open(cur_addr, O_TMPFILE | O_RDWR  , 0644);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;down_read(priv_data-&gt;rw_sem);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;err = vfs_copy_file_range(original_filp, 0, session_filp, 0, i_size_read(original_filp-&gt;f_inode), 0);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;up_read(priv_data-&gt;rw_sem);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;session_filp-&gt;f_flags = original_filp-&gt;f_flags;</div></div><!-- fragment --><p> this file will be pointed by the <em>private_data</em> field into the original file that is a special structure defined in the header which contains the session file pointer, the absolute path and a semaphore that is used to protect sessions during the close.</p><ul>
<li>Creates a node needed to keep track of opened file if not exists, else it increments atomically the counter:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;tmp_key = d_path(&amp;original_filp-&gt;f_path, tmp_addr, MAX_PATH_SIZE);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            f_node = rb_search_file(&amp;root_files, tmp_key, &amp;tree_rwlock_files);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            if(f_node== NULL)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                f_node = kmalloc(sizeof(struct session_file_node), GFP_KERNEL);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;                atomic_set(&amp;f_node-&gt;counter,1);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                strcpy(f_node-&gt;key, tmp_key);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                rb_insert_file(&amp;root_files, f_node, &amp;tree_rwlock_files);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;            }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;            else</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;            {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                atomic_inc(&amp;f_node-&gt;counter);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;            }</div></div><!-- fragment --><ul>
<li>Creates a <b>struct file_operations</b> based on the one present in the <em>original_filp</em> and replaces the needed operations with the new ones</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fops_replacement = kmalloc(sizeof(struct file_operations), GFP_KERNEL);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            *fops_replacement = (struct file_operations) *original_filp-&gt;f_op;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            fops_replacement-&gt;write = session_write;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            fops_replacement-&gt;read = session_read;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            fops_replacement-&gt;llseek = session_llseek;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;            fops_replacement-&gt;release = session_release;  </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;            replace_fops(original_filp, fops_replacement);</div></div><!-- fragment --><p>And finally it increments the global counter and the counter of the sessions opened by the process</p>
<h4>CLOSE_SESSION</h4>
<p>The close_session is responsible of closing the file and to copy the content of the session into the original file, all is done thanks to the function <em>delete</em> that after some operations makes its job: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;down_write(priv_data-&gt;rw_sem);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;vfs_truncate(&amp;filp-&gt;f_path, 0);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;err = vfs_copy_file_range(session_file, 0, filp, 0, file_size, 0); </div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;up_write(priv_data-&gt;rw_sem);</div></div><!-- fragment --><p>after that it restores the default file operations </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;replace_fops(filp, inodep-&gt;i_fop);</div></div><!-- fragment --><p>The delete returns an EPIPE error if the given file is removed from the filesystem, checking at the variable <em>i_nlink</em> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(inodep-&gt;i_nlink==0)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    send_sig(SIGPIPE, current, 1);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    up_write(priv_data-&gt;rw_sem);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    printk(KERN_ERR &quot;Sigpipe is sent&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    return -EPIPE;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> <h4>EXIT_SESSION</h4>
<p>The exit session represents the wish of closing the sessions, it just clear the processes tree, it's not really necessary just because all cleanup operations are made inside the release function related to the file, but maybe it can represent a</p>
<h2>Testcase and Benchmark</h2>
<h3>Correctness</h3>
<p>The whole developement had a test driven approach, all tests are contained into the tests/unit_tests folder, they were performed throught the <em>check</em>, a unit test framework. In particular the file test.c contains the main functions tested during the development, looking the code it's easy to understand that the tests were about:</p><ul>
<li>Initialization</li>
<li>Session operations on the file</li>
<li>Main errors</li>
<li>Sysfs correctness</li>
<li>Some basic tests on correctness with concurrency</li>
<li>Test of the correct raise of SIGPIPE</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Suite *s;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    TCase *tc_core;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    s = suite_create(&quot;Core functionalities Tests&quot;);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    tc_core = tcase_create(&quot;Core&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    tcase_add_test(tc_core, test_session_init);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    tcase_add_test(tc_core, test_file_op);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    tcase_add_test(tc_core, test_errors);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    tcase_add_test(tc_core, test_sysfs);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    tcase_add_test(tc_core, test_fork_processes);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    tcase_add_test_raise_signal(tc_core, test_signal, SIGPIPE);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    suite_add_tcase(s, tc_core);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    return s;</div></div><!-- fragment --> <h3>Performance</h3>
<p>The file perf_test compiled into the make with the *-pg* option tries many times a write operation with and without sessions: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(argc&lt;3)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(&quot;Usage: perf_test.c file1 file2&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int i;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;for(i=0; i&lt;TRIES;i++)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    write_with_session(argv[1]);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;for(i=0; i&lt;TRIES;i++)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    write_without_session(argv[2]);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;return 0;</div></div><!-- fragment --><p>The tests are performed initially with empty file and they shows no significant drop of performances with a relative low number of try. When tries are increased with the O_APPEND mode (more than 10k) the write with session takes more than the 99% of the time. The analysis is made with <b>gproof</b> with the following command into the terminal after the execution: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gprof perf_test gmon.out &gt; little_file_analysis</div></div><!-- fragment --><p> so the file <em>little_file_analysis</em> contains the report of the previous test.</p>
<p>the second test is performed with a medium file (2MB instead of 100byte) and 1k tries and with 10k tries. We can see that the drop of performace always belongs to the vfs_copy_file_range call into the kernel as we expected. All analysis are provided into the test folder. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
